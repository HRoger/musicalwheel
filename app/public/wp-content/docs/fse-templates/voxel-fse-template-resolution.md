# Voxel FSE Template Resolution

**Last Updated:** February 2026
**Status:** ✅ Working
**File:** `themes/voxel-fse/functions.php`

---

## Overview

Voxel stores all Design Menu templates (single post, archive, taxonomy term) as `wp_template` posts with custom slugs like `voxel-stays-single`, `voxel-stays-archive`, `voxel-term_single-pouit0fb`. These slugs are **never part of WordPress's standard template hierarchy**, so WordPress never finds them natively.

The solution is four filters in `functions.php`:

| Filter | Routes covered | Purpose |
|---|---|---|
| `single_template_hierarchy` | `/stays/my-listing/` | Injects `voxel-{post_type}-single` |
| `archive_template_hierarchy` | `/stays/` | Injects `voxel-{post_type}-archive` |
| `taxonomy_template_hierarchy` | `/areas/amsterdam/` | Injects `voxel-term_single-{key}` |
| `get_block_templates` | All three above | Wraps body-only content with header/footer |

---

## Why the Problem Exists

### Voxel slug patterns vs. WordPress hierarchy

WordPress's template resolution for each route type generates these candidate slugs:

```
Single post:      single-stays-my-listing → single-stays → single → index
Post type archive: archive-stays → archive → index
Taxonomy term:    taxonomy-area-amsterdam → taxonomy-area → taxonomy → archive → index
```

Voxel's FSE templates have slugs generated by `Template_Manager::generate_template_slug()`:

```
Single post:  voxel-{post_type_key}-single    → e.g. voxel-stays-single
Archive:      voxel-{post_type_key}-archive   → e.g. voxel-stays-archive
Term single:  voxel-term_single-{unique_key}  → e.g. voxel-term_single-pouit0fb
```

None of these match any candidate in WordPress's standard hierarchy. The three `*_template_hierarchy` filters fix this by prepending the Voxel slug at position 0 before WordPress searches.

### Why body-only templates need wrapping

Templates created via Voxel's Design Menu (single, archive, term_single) store **only body block content** — no `<!-- wp:template-part -->` wrappers for header and footer. The `get_block_templates` filter adds them at resolution time.

### Why `"theme":"voxel-fse"` is critical

When injecting header/footer template-part blocks, the `"theme"` attribute is mandatory for NectarBlocks. Its `render_template_part` filter (in `nectar-blocks/includes/Render/Render.php` line ~101) reads the `theme` attribute to call `get_block_template("voxel-fse//header")`, finds the template part's post ID, and reads its pre-computed CSS from `_nectar_blocks_css` post meta. Without `"theme"`, NectarBlocks skips CSS collection → broken header/footer layout (left-aligned, no columns).

---

## The Four Filters

### 1. `single_template_hierarchy`

Fires when WordPress resolves a single post page. Injects the base Voxel single template, or a custom `single_post` template if its visibility rules match.

```php
add_filter( 'single_template_hierarchy', function ( array $templates ): array {
    $post = get_queried_object();
    if ( ! $post instanceof \WP_Post ) {
        return $templates;
    }

    $post_type = \Voxel\Post_Type::get( $post->post_type );
    if ( ! ( $post_type && $post_type->is_managed_by_voxel() ) ) {
        return $templates;
    }

    // Check custom single_post templates (visibility rules) first
    $custom_templates = $post_type->templates->get_custom_templates()['single_post'] ?? [];
    foreach ( $custom_templates as $tpl ) {
        if ( ! empty( $tpl['visibility_rules'] ) && \Voxel\evaluate_visibility_rules( $tpl['visibility_rules'] ) ) {
            $unique_key = $tpl['unique_key'] ?? null;
            if ( $unique_key ) {
                array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-single-' . $unique_key );
            }
            return $templates;
        }
    }

    // Fall back to base single template
    array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-single' );

    return $templates;
} );
```

**Slug resolution logic:**
- Custom `single_post` templates (from "Single post" tab in Voxel admin) are evaluated top-to-bottom
- First template whose visibility rules pass → slug `voxel-{post_type}-single-{unique_key}`
- No custom match → base template slug `voxel-{post_type}-single`

**Why not `_wp_page_template` (Post Attributes dropdown)?**
WordPress's native template selector stores the chosen template in `_wp_page_template` post meta and prepends it to the hierarchy. It still works as a **per-post override** — our filter runs after that, but WordPress finds the explicitly-set template first. So the dropdown remains useful for one-off overrides; the filter handles the correct default automatically.

---

### 2. `archive_template_hierarchy`

Fires when WordPress resolves a post type archive page (e.g. `/stays/`). This is the Voxel-designed explore/browse page with post feed and search form — not a generic WordPress archive list.

```php
add_filter( 'archive_template_hierarchy', function ( array $templates ): array {
    if ( ! is_post_type_archive() ) {
        return $templates;
    }

    $queried = get_queried_object();
    if ( ! $queried instanceof \WP_Post_Type ) {
        return $templates;
    }

    $post_type = \Voxel\Post_Type::get( $queried->name );
    if ( ! ( $post_type && $post_type->is_managed_by_voxel() ) ) {
        return $templates;
    }

    // Slug pattern: "voxel-{post_type_key}-archive"
    array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-archive' );

    return $templates;
} );
```

**Note on `is_post_type_archive()` guard:** The `archive_template_hierarchy` filter also fires for date archives, author archives, etc. The guard ensures we only intercept custom post type archive URLs, not generic WordPress archives.

**Why Voxel's own `has_archive_page()` doesn't work in FSE:**
Voxel's `post-controller.php` fires `do_action('voxel/post-type-archive')` which calls `print_archive_template()` — but that method checks `\Voxel\is_elementor_active()` and returns early in FSE mode. Our filter bypasses this Elementor-specific path entirely.

---

### 3. `taxonomy_template_hierarchy`

Fires when WordPress resolves a taxonomy term page (e.g. `/areas/amsterdam/`). Term templates use a globally-scoped slug with a random `unique_key` suffix because multiple term templates can exist with different visibility rules (unlike single/archive which have one base template per post type).

```php
add_filter( 'taxonomy_template_hierarchy', function ( array $templates ): array {
    $term = get_queried_object();
    if ( ! $term instanceof \WP_Term ) {
        return $templates;
    }

    $voxel_term = \Voxel\Term::get( $term );
    $taxonomy   = $voxel_term ? $voxel_term->taxonomy : null;
    if ( ! ( $taxonomy && $taxonomy->is_managed_by_voxel() ) ) {
        return $templates;
    }

    $custom_templates = \Voxel\get_custom_templates()['term_single'] ?? [];
    if ( empty( $custom_templates ) ) {
        return $templates;
    }

    // First template with passing visibility rules, else first available
    $matched = null;
    foreach ( $custom_templates as $tpl ) {
        if ( ! empty( $tpl['visibility_rules'] ) && \Voxel\evaluate_visibility_rules( $tpl['visibility_rules'] ) ) {
            $matched = $tpl;
            break;
        }
    }

    if ( ! $matched ) {
        $matched = $custom_templates[0];
    }

    $unique_key = $matched['unique_key'] ?? null;
    if ( ! $unique_key ) {
        return $templates;
    }

    array_unshift( $templates, 'voxel-term_single-' . $unique_key );

    return $templates;
} );
```

**Why `get_custom_templates()` not `get_single_term_template_id()`:**
`get_single_term_template_id()` (in `voxel/app/utils/post-utils.php`) returns only a post ID, only matches templates with **non-empty** matching rules, and gives no fallback when no rules match. We need the `unique_key` to construct the slug, plus the fallback to the first template when nothing matches — so we read `voxel:custom_templates` from `wp_options` directly.

**Slug storage:** `unique_key` is an 8-char lowercase alphanumeric string generated once at template creation:
```json
{
  "term_single": [
    { "label": "Areas Term", "id": 123, "unique_key": "pouit0fb", "visibility_rules": [] }
  ]
}
```
Stored in `wp_options` key `voxel:custom_templates`, readable via `\Voxel\get_custom_templates()`.

---

### 4. `get_block_templates`

Fires after WordPress resolves the `wp_template` posts matching the hierarchy. At this point, we know which Voxel template was selected. We wrap its body-only content with header and footer template-part blocks.

```php
add_filter( 'get_block_templates', function ( array $query_result ): array {
    $theme  = get_stylesheet();
    $header = '<!-- wp:template-part {"slug":"header","tagName":"header","theme":"' . $theme . '"} /-->';
    $footer = '<!-- wp:template-part {"slug":"footer","tagName":"footer","theme":"' . $theme . '"} /-->';

    foreach ( $query_result as $template ) {
        // Match all three Voxel template types:
        // - voxel-term_single-*       (taxonomy term)
        // - voxel-{post_type}-single  (single post)
        // - voxel-{post_type}-archive (post type archive)
        $is_voxel_template = (
            strpos( $template->slug, 'voxel-term_single' ) === 0
            || preg_match( '/^voxel-[a-z0-9_]+-(single|archive)/', $template->slug )
        );

        if ( ! $is_voxel_template ) {
            continue;
        }

        // Skip if already wrapped (idempotent)
        if ( strpos( $template->content, '"slug":"header"' ) !== false ) {
            continue;
        }

        $template->content = $header . "\n\n" . trim( $template->content ) . "\n\n" . $footer;
    }

    return $query_result;
}, 10, 1 );
```

**This filter is also where the NectarBlocks CSS chain starts.** During `get_the_block_template_html()` (which runs at line 12 of `template-canvas.php`, before `wp_head()`), `render_block()` processes the injected template-part blocks and NectarBlocks' `render_template_part` filter collects their CSS into `$nectar_template_parts_css`. By the time `wp_enqueue_scripts` fires at priority 99, NectarBlocks has the CSS ready to inline.

---

## NectarBlocks `$post` Null Workaround

On archive/taxonomy/author pages, `$post` is `null`. NectarBlocks reads `$post->post_content` at `wp_enqueue_scripts` priority 99 without a null guard. This hook provides a safe stub object at priority 98:

```php
add_action( 'wp_enqueue_scripts', function () {
    global $post;
    if ( $post === null && ( is_tax() || is_category() || is_tag() || is_archive() || is_author() ) ) {
        $post = (object) [ 'ID' => 0, 'post_content' => '' ];
    }
}, 98 );
```

---

## Complete Execution Pipeline

```
User visits /stays/my-listing/  (or /stays/  or /areas/amsterdam/)
    ↓
WordPress calls get_query_template()
  → builds PHP candidate list (single-stays-my-listing, single-stays, single...)
    ↓
single_template_hierarchy filter  (or archive_ / taxonomy_ variant)
  → prepends Voxel slug at position 0
  → e.g. ['voxel-stays-single', 'single-stays-my-listing', 'single-stays', ...]
    ↓
locate_block_template() / resolve_block_template()
  → strips .php extensions → queries get_block_templates(['slug__in' => $slugs])
    ↓
get_block_templates filter fires
  → finds the voxel-* template in the result set
  → prepends: <!-- wp:template-part {"slug":"header","theme":"voxel-fse"} /-->
  → appends:  <!-- wp:template-part {"slug":"footer","theme":"voxel-fse"} /-->
    ↓
WordPress sets $_wp_current_template_content = wrapped block markup
Sets template file = template-canvas.php
    ↓
template-canvas.php line 12: $template_html = get_the_block_template_html()
  → render_block() processes header template-part
      → NectarBlocks render_template_part filter reads "theme" attr
      → calls get_block_template("voxel-fse//header")
      → reads _nectar_blocks_css post meta from header template part post
      → stores CSS in $nectar_template_parts_css global
  → render_block() processes body blocks (post feed, hero, etc.)
  → render_block() processes footer template-part (same CSS collection)
    ↓
wp_head() runs
  → wp_enqueue_scripts priority 98: $post null stub set if needed
  → wp_enqueue_scripts priority 99: NectarBlocks frontend_render_styles()
      → reads $nectar_template_parts_css → inlines header + footer CSS
      → reads _nectar_blocks_css from current template post → inlines body CSS
    ↓
echo $template_html  →  full page with correct NectarBlocks layout CSS
```

---

## `author.php` — PHP Override (Cannot Use Hierarchy Filter)

Author pages (`/author/{username}/`) are handled by `author.php` in the child theme root, not via a hierarchy filter, because they require PHP context-setting before any block rendering:

```php
\Voxel\set_current_post( $user->get_or_create_profile() );
```

This must run before `get_the_block_template_html()`. Hierarchy filters fire too early for this. So `author.php` stays as a PHP override — but it uses the same wrapping pattern with `"theme":"voxel-fse"` on the template-part blocks to ensure NectarBlocks CSS loads correctly.

---

## Template Slug Reference

| Template type | Slug pattern | Example | Source |
|---|---|---|---|
| Single post (base) | `voxel-{post_type}-single` | `voxel-stays-single` | `Template_Manager::generate_template_slug()` |
| Single post (custom) | `voxel-{post_type}-single-{unique_key}` | `voxel-stays-single-ab3f9c12` | `custom-templates-handler.php` |
| Archive | `voxel-{post_type}-archive` | `voxel-stays-archive` | `Template_Manager::generate_template_slug()` |
| Term single | `voxel-term_single-{unique_key}` | `voxel-term_single-pouit0fb` | `design-menu-ajax-handlers.php` |
| Header (Design Menu) | `voxel-header-{unique_key}` | — | `design-menu-ajax-handlers.php` |
| Footer (Design Menu) | `voxel-footer-{unique_key}` | — | `design-menu-ajax-handlers.php` |

`unique_key` is always `strtolower(\Voxel\random_string(8))` — 8-char lowercase alphanumeric, generated once at template creation.

---

## Files Reference

| File | Role |
|---|---|
| `themes/voxel-fse/functions.php` | All four filters live here |
| `themes/voxel-fse/author.php` | PHP override for author/profile pages |
| `themes/voxel-fse/taxonomy.php.bak` | Disabled — replaced by `taxonomy_template_hierarchy` filter |
| `themes/voxel-fse/templates/single.html` | Generic FSE fallback for non-Voxel single posts |
| `themes/voxel-fse/templates/archive.html` | Generic FSE fallback for non-Voxel archives |
| `themes/voxel/app/utils/template-utils.php` | `get_custom_templates()` — reads `voxel:custom_templates` |
| `themes/voxel/app/utils/post-utils.php` | `get_single_post_template_id()` — Voxel's own resolver (not used by us) |
| `themes/voxel/app/post-types/post-type-templates.php` | `get_custom_templates()` per post type — `single`, `card`, `single_post` groups |
| `themes/voxel-fse/app/controllers/fse-templates/template-manager.php` | `create_fse_template()`, `generate_template_slug()` |
| `themes/voxel-fse/app/controllers/fse-templates/custom-templates-handler.php` | Intercepts Voxel AJAX for custom single_post template creation |
| `plugins/nectar-blocks/includes/Render/Render.php` | `render_template_part()` (~74), `frontend_render_styles()` (~602) |
| `wp-includes/template.php` | `get_query_template()` — fires `{type}_template_hierarchy` filter |
| `wp-includes/block-template.php` | `locate_block_template()`, `resolve_block_template()` |
| `wp-includes/template-canvas.php` | Runs `get_the_block_template_html()` before `wp_head()` |
