# Voxel FSE Template Resolution

**Last Updated:** February 2026
**Status:** ✅ Working
**File:** `themes/voxel-fse/functions.php`, `themes/voxel-fse/author.php`

---

## Overview

Voxel stores all Design Menu templates (single post, archive, taxonomy term) as `wp_template` posts with custom slugs like `voxel-stays-single`, `voxel-stays-archive`, `voxel-term_single-pouit0fb`. These slugs are **never part of WordPress's standard template hierarchy**, so WordPress never finds them natively.

The solution is four filters in `functions.php` plus one PHP override file:

| Mechanism | Routes covered | Purpose |
|---|---|---|
| `single_template_hierarchy` filter | `/stays/my-listing/` | Injects `voxel-{post_type}-single` |
| `archive_template_hierarchy` filter | `/stays/` | Injects `voxel-{post_type}-archive` |
| `taxonomy_template_hierarchy` filter | `/areas/amsterdam/` | Injects `voxel-term_single-{key}` |
| `get_block_templates` filter | All three above | Wraps body-only content with header/footer |
| `author.php` PHP override | `/author/{username}/` | Sets Voxel profile context, then triggers FSE pipeline |

---

## Why the Problem Exists

### Voxel slug patterns vs. WordPress hierarchy

WordPress's template resolution for each route type generates these candidate slugs:

```
Single post:       single-stays-my-listing → single-stays → single → index
Post type archive: archive-stays → archive → index
Taxonomy term:     taxonomy-area-amsterdam → taxonomy-area → taxonomy → archive → index
Author page:       author-{username} → author → archive → index
```

Voxel's FSE templates have slugs generated by `Template_Manager::generate_template_slug()`:

```
Single post:  voxel-{post_type_key}-single    e.g. voxel-stays-single
Archive:      voxel-{post_type_key}-archive   e.g. voxel-stays-archive
Term single:  voxel-term_single-{unique_key}  e.g. voxel-term_single-pouit0fb
```

None of these match any candidate in WordPress's standard hierarchy. The three `*_template_hierarchy` filters fix this by prepending the Voxel slug at position 0 before WordPress searches.

### Why body-only templates need wrapping

Templates created via Voxel's Design Menu store **only body block content** — no `<!-- wp:template-part -->` wrappers for header and footer. The `get_block_templates` filter adds them at resolution time.

### Why `"theme":"voxel-fse"` is critical in template-part blocks

When injecting header/footer template-part blocks, the `"theme"` attribute is mandatory for NectarBlocks. Its `render_template_part` filter (`nectar-blocks/includes/Render/Render.php` line ~101) reads the `theme` attribute to call `get_block_template("voxel-fse//header")`, finds the template part's post ID, and reads its pre-computed CSS from `_nectar_blocks_css` post meta. Without `"theme"`, NectarBlocks skips CSS collection → broken header/footer layout (left-aligned, no columns).

---

## The Four Filters

### 1. `single_template_hierarchy`

Fires when WordPress resolves a single post page. Injects the base Voxel single template, or a custom `single_post` template if its visibility rules match.

```php
add_filter( 'single_template_hierarchy', function ( array $templates ): array {
    $post = get_queried_object();
    if ( ! $post instanceof \WP_Post ) {
        return $templates;
    }

    $post_type = \Voxel\Post_Type::get( $post->post_type );
    if ( ! ( $post_type && $post_type->is_managed_by_voxel() ) ) {
        return $templates;
    }

    // Check custom single_post templates (visibility rules) first
    $custom_templates = $post_type->templates->get_custom_templates()['single_post'] ?? [];
    foreach ( $custom_templates as $tpl ) {
        if ( ! empty( $tpl['visibility_rules'] ) && \Voxel\evaluate_visibility_rules( $tpl['visibility_rules'] ) ) {
            $unique_key = $tpl['unique_key'] ?? null;
            if ( $unique_key ) {
                array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-single-' . $unique_key );
            }
            return $templates;
        }
    }

    // Fall back to base single template
    array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-single' );

    return $templates;
} );
```

**Slug resolution logic:**
- Custom `single_post` templates (from "Single post" tab in Voxel admin) are evaluated top-to-bottom
- First template whose visibility rules pass → slug `voxel-{post_type}-single-{unique_key}`
- No custom match → base template slug `voxel-{post_type}-single`

**Why not `_wp_page_template` (Post Attributes dropdown)?**
WordPress's native template selector stores the chosen template in `_wp_page_template` post meta and prepends it to the hierarchy before our filter runs — so it still works as a **per-post override**. Our filter handles the correct default automatically; the dropdown is available for one-off exceptions.

---

### 2. `archive_template_hierarchy`

Fires when WordPress resolves a post type archive page (e.g. `/stays/`). This is the Voxel-designed explore/browse page with post feed and search form — not a generic WordPress post list.

```php
add_filter( 'archive_template_hierarchy', function ( array $templates ): array {
    if ( ! is_post_type_archive() ) {
        return $templates;
    }

    $queried = get_queried_object();
    if ( ! $queried instanceof \WP_Post_Type ) {
        return $templates;
    }

    $post_type = \Voxel\Post_Type::get( $queried->name );
    if ( ! ( $post_type && $post_type->is_managed_by_voxel() ) ) {
        return $templates;
    }

    // Slug pattern: "voxel-{post_type_key}-archive"
    array_unshift( $templates, 'voxel-' . $post_type->get_key() . '-archive' );

    return $templates;
} );
```

**Why the `is_post_type_archive()` guard:** The `archive_template_hierarchy` filter also fires for date archives, author archives, etc. The guard ensures we only intercept custom post type archive URLs.

**Why Voxel's own `has_archive_page()` doesn't work in FSE:**
Voxel's `post-controller.php` fires `do_action('voxel/post-type-archive')` which calls `print_archive_template()` — but that method checks `\Voxel\is_elementor_active()` and returns early in FSE mode. Our filter bypasses this Elementor-specific code path entirely.

---

### 3. `taxonomy_template_hierarchy`

Fires when WordPress resolves a taxonomy term page (e.g. `/areas/amsterdam/`). Term templates use a globally-scoped slug with a random `unique_key` suffix because multiple term templates can exist with different visibility rules (unlike single/archive which have one base template per post type).

```php
add_filter( 'taxonomy_template_hierarchy', function ( array $templates ): array {
    $term = get_queried_object();
    if ( ! $term instanceof \WP_Term ) {
        return $templates;
    }

    $voxel_term = \Voxel\Term::get( $term );
    $taxonomy   = $voxel_term ? $voxel_term->taxonomy : null;
    if ( ! ( $taxonomy && $taxonomy->is_managed_by_voxel() ) ) {
        return $templates;
    }

    $custom_templates = \Voxel\get_custom_templates()['term_single'] ?? [];
    if ( empty( $custom_templates ) ) {
        return $templates;
    }

    // First template with passing visibility rules, else first available
    $matched = null;
    foreach ( $custom_templates as $tpl ) {
        if ( ! empty( $tpl['visibility_rules'] ) && \Voxel\evaluate_visibility_rules( $tpl['visibility_rules'] ) ) {
            $matched = $tpl;
            break;
        }
    }

    if ( ! $matched ) {
        $matched = $custom_templates[0];
    }

    $unique_key = $matched['unique_key'] ?? null;
    if ( ! $unique_key ) {
        return $templates;
    }

    array_unshift( $templates, 'voxel-term_single-' . $unique_key );

    return $templates;
} );
```

**Why `get_custom_templates()` not `get_single_term_template_id()`:**
`get_single_term_template_id()` (`voxel/app/utils/post-utils.php`) returns only a post ID, only matches templates with **non-empty** matching rules, and gives no fallback when nothing matches. We need the `unique_key` to construct the slug, plus the fallback to the first template — so we read `voxel:custom_templates` from `wp_options` directly.

**Slug storage:** `unique_key` is an 8-char lowercase alphanumeric string generated once at template creation and stored in `wp_options` key `voxel:custom_templates`:
```json
{
  "term_single": [
    { "label": "Areas Term", "id": 123, "unique_key": "pouit0fb", "visibility_rules": [] }
  ]
}
```
Readable via `\Voxel\get_custom_templates()` (`themes/voxel/app/utils/template-utils.php`).

---

### 4. `get_block_templates`

Fires after WordPress resolves the `wp_template` posts matching the hierarchy. At this point we know which Voxel template was selected — we wrap its body-only content with header and footer template-part blocks.

```php
add_filter( 'get_block_templates', function ( array $query_result ): array {
    $theme  = get_stylesheet();
    $header = '<!-- wp:template-part {"slug":"header","tagName":"header","theme":"' . $theme . '"} /-->';
    $footer = '<!-- wp:template-part {"slug":"footer","tagName":"footer","theme":"' . $theme . '"} /-->';

    foreach ( $query_result as $template ) {
        // Match all three Voxel template types:
        // - voxel-term_single-*       (taxonomy term)
        // - voxel-{post_type}-single  (single post)
        // - voxel-{post_type}-archive (post type archive)
        $is_voxel_template = (
            strpos( $template->slug, 'voxel-term_single' ) === 0
            || preg_match( '/^voxel-[a-z0-9_]+-(single|archive)/', $template->slug )
        );

        if ( ! $is_voxel_template ) {
            continue;
        }

        // Skip if already wrapped (idempotent)
        if ( strpos( $template->content, '"slug":"header"' ) !== false ) {
            continue;
        }

        $template->content = $header . "\n\n" . trim( $template->content ) . "\n\n" . $footer;
    }

    return $query_result;
}, 10, 1 );
```

**This filter is where the NectarBlocks CSS chain starts.** During `get_the_block_template_html()` (line 12 of `template-canvas.php`, before `wp_head()`), `render_block()` processes the injected template-part blocks and NectarBlocks' `render_template_part` filter collects their CSS into `$nectar_template_parts_css`. By the time `wp_enqueue_scripts` fires at priority 99, NectarBlocks has the CSS ready to inline.

---

## `author.php` — PHP Override

### The route

WordPress's author URL (`/author/{username}/`) maps to the user's Voxel `profile` post type. It is NOT a single post page — it's an author archive, so `single_template_hierarchy` never fires for it. WordPress resolves it via `author_template_hierarchy` → `author.php` in the child theme root.

### Why a hierarchy filter cannot be used here

Author pages require **PHP context-setting before any block rendering begins**:

```php
\Voxel\set_current_post( $user->get_or_create_profile() );
```

This call sets the current Voxel post context to the user's profile post, so dynamic tags (e.g. `@post.title`, `@post.fields.bio`) resolve to the correct user's data when blocks render. If we used `author_template_hierarchy` to inject a slug and let WordPress find the template natively, `get_the_block_template_html()` would run before this context is set — all dynamic tags would resolve to nothing.

Hierarchy filters fire during template resolution (before rendering). Context-setting must happen between template selection and rendering. The only way to do both is a PHP template file that sets context, then manually triggers the FSE rendering pipeline.

### The original bug (now fixed)

The original `author.php` injected template-part blocks **without** the `"theme"` attribute:

```php
// ❌ Old — NectarBlocks cannot find the template part, skips CSS
'<!-- wp:template-part {"slug":"header","tagName":"header"} /-->'
```

This had the same consequence as the original taxonomy bug: NectarBlocks' `render_template_part` filter bails when `theme` is absent, so it never reads `_nectar_blocks_css` from the header/footer template part posts. Result: header and footer rendered with broken layout (no columns, left-aligned).

It also had a duplicate NectarBlocks `$post` null workaround registered inside `author.php` itself — redundant because `functions.php` already covers `is_author()`.

### The fix

`author.php` now builds `$header` and `$footer` once at the top with the `theme` attribute, reuses them in all code paths, and removes the duplicate null workaround:

```php
$theme  = get_stylesheet();
$header = '<!-- wp:template-part {"slug":"header","tagName":"header","theme":"' . $theme . '"} /-->';
$footer = '<!-- wp:template-part {"slug":"footer","tagName":"footer","theme":"' . $theme . '"} /-->';
```

### What `author.php` does (step by step)

```
1. Get profile post type — bail if not Voxel-managed
   → fall back to templates/archive.html
2. Build $header / $footer strings with "theme" attribute
3. Get the WP_User for the author being viewed
   → if not found: render error message with header/footer → return
4. \Voxel\set_current_post( $user->get_or_create_profile() )
   → establishes Voxel dynamic tag context for this user's profile
5. \Voxel\get_single_post_template_id( $post_type )
   → returns the profile single template's wp_post ID (not a wp_template slug)
   → if none / password-protected: render error message → return
6. get_post( $template_id )
   → retrieves the wp_post with the template's body block content
   → if not found: render error message → return
7. Set $_wp_current_template_content = $header . $template_post->post_content . $footer
   Set $_wp_current_template_id      = "voxel-fse//index"
8. include template-canvas.php
   → get_the_block_template_html() renders the wrapped content
   → NectarBlocks collects header/footer CSS (theme attr present ✅)
   → Voxel dynamic tags resolve from the profile context set in step 4 ✅
```

---

## NectarBlocks `$post` Null Workaround

On archive/taxonomy/author pages, `$post` is `null`. NectarBlocks reads `$post->post_content` at `wp_enqueue_scripts` priority 99 without a null guard. This hook in `functions.php` provides a safe stub object at priority 98 (just before):

```php
add_action( 'wp_enqueue_scripts', function () {
    global $post;
    if ( $post === null && ( is_tax() || is_category() || is_tag() || is_archive() || is_author() ) ) {
        $post = (object) [ 'ID' => 0, 'post_content' => '' ];
    }
}, 98 );
```

This is registered **globally in `functions.php`** — not in individual template files. It covers all non-singular page types in one place.

---

## Complete Execution Pipeline

```
User visits /stays/my-listing/  (or /stays/  or /areas/amsterdam/)
    ↓
WordPress calls get_query_template()
  → builds PHP candidate list (single-stays-my-listing, single-stays, single...)
    ↓
single_template_hierarchy filter  (or archive_ / taxonomy_ variant)
  → prepends Voxel slug at position 0
  → ['voxel-stays-single', 'single-stays-my-listing', 'single-stays', ...]
    ↓
locate_block_template() / resolve_block_template()
  → strips .php extensions → queries get_block_templates(['slug__in' => $slugs])
    ↓
get_block_templates filter fires
  → finds the voxel-* template in the result set
  → prepends: <!-- wp:template-part {"slug":"header","theme":"voxel-fse"} /-->
  → appends:  <!-- wp:template-part {"slug":"footer","theme":"voxel-fse"} /-->
    ↓
WordPress sets $_wp_current_template_content = wrapped block markup
Sets template file = template-canvas.php
    ↓
template-canvas.php line 12: $template_html = get_the_block_template_html()
  → render_block() processes header template-part
      → NectarBlocks render_template_part filter reads "theme" attr
      → calls get_block_template("voxel-fse//header")
      → reads _nectar_blocks_css post meta → stores in $nectar_template_parts_css
  → render_block() processes body blocks (post feed, hero, etc.)
  → render_block() processes footer template-part (same CSS collection)
    ↓
wp_head() runs
  → wp_enqueue_scripts priority 98: $post null stub set if needed
  → wp_enqueue_scripts priority 99: NectarBlocks frontend_render_styles()
      → reads $nectar_template_parts_css → inlines header + footer CSS
      → reads _nectar_blocks_css from current template → inlines body CSS
    ↓
echo $template_html  →  full page with correct NectarBlocks layout CSS


User visits /author/{username}/
    ↓
WordPress finds author.php in child theme root (wins over parent author.php)
    ↓
author.php runs:
  → resolves 'profile' post type
  → builds $header / $footer with "theme":"voxel-fse"
  → gets WP_User for the queried author
  → \Voxel\set_current_post( $user->get_or_create_profile() )  ← context set HERE
  → get_single_post_template_id( $post_type ) → profile template post ID
  → get_post( $template_id ) → template body content
  → sets $_wp_current_template_content = $header . body . $footer
  → includes template-canvas.php
    ↓
(same template-canvas.php flow as above from this point)
```

---

## Template Slug Reference

| Template type | Slug pattern | Example | Source |
|---|---|---|---|
| Single post (base) | `voxel-{post_type}-single` | `voxel-stays-single` | `Template_Manager::generate_template_slug()` |
| Single post (custom) | `voxel-{post_type}-single-{unique_key}` | `voxel-stays-single-ab3f9c12` | `custom-templates-handler.php` |
| Archive | `voxel-{post_type}-archive` | `voxel-stays-archive` | `Template_Manager::generate_template_slug()` |
| Term single | `voxel-term_single-{unique_key}` | `voxel-term_single-pouit0fb` | `design-menu-ajax-handlers.php` |
| Header (Design Menu) | `voxel-header-{unique_key}` | — | `design-menu-ajax-handlers.php` |
| Footer (Design Menu) | `voxel-footer-{unique_key}` | — | `design-menu-ajax-handlers.php` |

`unique_key` is always `strtolower(\Voxel\random_string(8))` — 8-char lowercase alphanumeric, generated once at template creation.

---

## Files Reference

| File | Role |
|---|---|
| `themes/voxel-fse/functions.php` | All four filters + NectarBlocks null workaround |
| `themes/voxel-fse/author.php` | PHP override for author/profile pages |
| `themes/voxel-fse/taxonomy.php.bak` | Disabled — replaced by `taxonomy_template_hierarchy` filter |
| `themes/voxel-fse/templates/single.html` | Generic FSE fallback for non-Voxel single posts |
| `themes/voxel-fse/templates/archive.html` | Generic FSE fallback for non-Voxel archives |
| `themes/voxel/app/utils/template-utils.php` | `get_custom_templates()` — reads `voxel:custom_templates` |
| `themes/voxel/app/utils/post-utils.php` | `get_single_post_template_id()` — used by author.php |
| `themes/voxel/app/post-types/post-type-templates.php` | `get_custom_templates()` per post type — `single`, `card`, `single_post` groups |
| `themes/voxel-fse/app/controllers/fse-templates/template-manager.php` | `create_fse_template()`, `generate_template_slug()` |
| `themes/voxel-fse/app/controllers/fse-templates/custom-templates-handler.php` | Intercepts Voxel AJAX for custom single_post template creation |
| `plugins/nectar-blocks/includes/Render/Render.php` | `render_template_part()` (~74), `frontend_render_styles()` (~602) |
| `wp-includes/template.php` | `get_query_template()` — fires `{type}_template_hierarchy` filter |
| `wp-includes/block-template.php` | `locate_block_template()`, `resolve_block_template()` |
| `wp-includes/template-canvas.php` | Runs `get_the_block_template_html()` before `wp_head()` |
